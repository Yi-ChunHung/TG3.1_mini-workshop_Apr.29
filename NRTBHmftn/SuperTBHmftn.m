%%%        Program for Constructing SuperCell ftn58sparse            %%%
%%% ---------------------------------------------------------------- %%%
%%% Necessary Input files:                                           %%%
%%% 1) ftn58sparse.mat                                               %%%
%%% 2) slab_info.mat (generated by SuperCell.m)                      %%%
%%% ---------------------------------------------------------------- %%%
%%% 19 Nov created by Hans                                           %%%
%%% ---------------------------------------------------------------- %%%
% clear all
function SuperTBHmftn()

    %%% Input this manually %%%
    wcal = ReadInput('input.txt');
    isRT   = 0;
    RT     = [1 -1 0;1 1 0;0 0 sqrt(2)]/sqrt(2);
    % InFile = 'ftn58sparse_cut_p.mat';
    %%% ------------------- %%%
    
    tic
    %% --- Read Input information --- %%%
    instruct    = load(wcal.file);
    if isfield(instruct,'ftn58sparse')
        ftn58sparse = instruct.ftn58sparse;
    elseif isfield(instruct,'SPftn58sparse')
        ftn58sparse = instruct.SPftn58sparse;
    else
        ftn58sparse = instruct.Sftn58sparse;
        ftn58sparse.dd = [ftn58sparse.dd,zeros(size(ftn58sparse.dd,1),1)];
        hkl         = ftn58sparse.hkl;
        BR3D        = ftn58sparse.BR3D;
    end
    load('slab_info.mat');
    
    dd  = ftn58sparse.dd*BR/NBR;
    ib1 = ftn58sparse.ij(:,1);
    ib2 = ftn58sparse.ij(:,2);
    tt  = ftn58sparse.tt;
    nbd = length(tt);
    
    ijs = zeros(length(dd)*50,2);
    tts = zeros(length(dd)*50,1);
    dds = zeros(length(dd)*50,3);
    
    %% --- Actual Procedure --- %%%
    fid = fopen('super_ftn58.dat','w');
    kk=1;
    totorbitps = [orbitps;sporbitps];
    %--- total number of needed orbitals (in a unit cell) 
    for ii=1:size(orbitps, 1) 
        if mod(ii,10)==0
            fprintf('# of Orbital = %4i/%i\n',ii,size(orbitps,1));
        end
        %--- look for all possible translations of obrital(i)
        temp1 = find(ib1==orbitps(ii,2)); 
        %--- run over all B
        for jj=1:size(temp1, 1) 
            %--- look for hopping parameters of orbital(i) and all required orbitals
            temp2 = find(totorbitps(:,2)==ib2(temp1(jj))); 
            if(temp2>0)
                %--- vector points from orb1 --> orb2 
                component = totorbitps(temp2(1),7:9) - totorbitps(ii,7:9) + dd(temp1(jj),:);
                %--- displacement of orb(ii) to orb(jj)
                dist = totorbitps(temp2(:),4:6) - repmat(totorbitps(ii,4:6),[length(temp2) 1]);
                %--- difference of component and dist
                disp = repmat(component,[length(temp2) 1]) - dist;
                %--- reduce the digit points
                disp = round(disp,2);
                %--- find the vector with integer translation, which
                %corresponds to superatoms. 
                hopp = find(mod(disp(:,1),1)==0&mod(disp(:,2),1)==0&mod(disp(:,3),1)==0);
                if (hopp>0&&temp2(hopp)>size(orbitps,1))
                    hopid = find(sptable(:,1)==totorbitps(temp2(hopp),2));
                    % ijs(kk,:) = [ii sptable(hopid,2)];
                    % tts(kk,:) = tt(temp1(jj));
                    % dds(kk,:) = disp(hopp,:);
    %                 ijs(kk+1,:) = [sptable(totorbitps(temp2(hopp),2),2) ii];
    %                 tts(kk+1,:) = conj(tt(temp1(jj)));
    %                 dds(kk+1,:) = -disp(hopp,:);
                    fprintf(fid,"%5d\t%5d\t%10.8f\t%10.8f\t%5d\t%5d\t%5d\n",ii,sptable(hopid,2),real(tt(temp1(jj))),imag(tt(temp1(jj))),disp(hopp,:));
                    kk = kk + 1;
                elseif (hopp>0)
                    % ijs(kk,:) = [ii totorbitps(temp2(hopp),1)];
                    % tts(kk,:) = tt(temp1(jj));
                    % dds(kk,:) = disp(hopp,:);
                    fprintf(fid,"%5d\t%5d\t%10.8f\t%10.8f\t%5d\t%5d\t%5d\n",ii,totorbitps(temp2(hopp),1),real(tt(temp1(jj))),imag(tt(temp1(jj))),disp(hopp,:));
                    kk = kk + 1;
                end
            end
        end
    end
    
    fclose(fid);
    toc
    
    %% --- reread the ij, tt, dd --- %%%
    ftn58_temp = [];
    fid             = fopen('super_ftn58.dat','r');
    format          = '%d %d %f %f %d %d %d';
    sizeftn58       = [7 Inf];
    ftn58           = fscanf(fid,format,sizeftn58);
    ftn58_temp      = ftn58';
    ftn58_temp(:,3) = ftn58_temp(:,3) + 1i*ftn58_temp(:,4);
    ftn58_temp(:,4) = [];
    fclose(fid);
    
    ijs = ftn58_temp(1:kk-1,1:2);
    tts = ftn58_temp(1:kk-1,3);
    dds = ftn58_temp(1:kk-1,4:6);
    
    %% --- Rotating the new unit vectors --- %%
    if (isRT)
        BR = BR*RT'; 
    end
    
    %% --- Save as Sftn58sparse format --- %%%
    for i=1:ftn58sparse.Nat
        aname = getfield(ftn58sparse.Ainfo, {i}, 'Atom');
    end
    
    %% ------------------------------------------------------------
    %%% if the supercell is built for slab with normal (001) in BR2D
    if isSlab
        atomps(:,3)    = atomps(:,3)*num_layer;
        atomps(:,6:8)  = atomps(:,1:3)*BR;
        atomps(:,9:11) = atomps(:,6:8)/NBR;
        %orbitps(:,4:6) = atomps(:,9:11);
        orbitps(:,4:6) = ((orbitps(:,4:6)*NBR)/BR);
        orbitps(:,6)   = orbitps(:,6)*num_layer;
        orbitps(:,4:6) = (orbitps(:,4:6)*BR)/NBR;
    end
    %% ------------------------------------------------------------
    
    for i=1:size(atomps,1)
        atominfo(i).Atom(1,:) = getfield(ftn58sparse.Ainfo, {atomps(i,5)}, 'Atom');
        atominfo(i).Position(1,1:3) = atomps(i,9:11);
        atominfo(i).Norb = atomps(i,4);
    %     atominfo(i).OrbitIndex = getfield(ftn58sparse.Ainfo, {atomps(i,5)}, 'OrbitIndex');
        atominfo(i).OrbitIndex = [(sum(atomps(1:i,4),1) - atomps(i,4) + 1):sum(atomps(1:i,4),1)]; 
        atominfo(i).Orbit(1,:) = getfield(ftn58sparse.Ainfo, {atomps(i,5)}, 'Orbit');
        atominfo(i).OrbitID    = getfield(ftn58sparse.Ainfo, {atomps(i,5)}, 'OrbitID');
    end
    
    SPftn58sparse.System  = 'ftn58';
    SPftn58sparse.Ainfo   = atominfo;
    SPftn58sparse.abc     = ftn58sparse.abc;
    SPftn58sparse.Nat     = length(atominfo); 
    SPftn58sparse.ver     = 'type1';
    SPftn58sparse.isSO    = ftn58sparse.isSO;
    SPftn58sparse.norb    = size(orbitps,1);
    SPftn58sparse.Orbitps = [orbitps(1:end,1:3) orbitps(1:end,4:6) orbitps(1:end,10)];
    SPftn58sparse.ij      = ijs;
    SPftn58sparse.tt      = tts;
    SPftn58sparse.dd      = dds(:,:);
    SPftn58sparse.latss   = U2STR;
    if isSlab
        SPftn58sparse.BR2D = NBR;
        SPftn58sparse.hkl  = hkl;
        SPftn58sparse.BR3D = BR3D;
    else
        SPftn58sparse.BR   = NBR;
    end
    
    SPftn58sparse         = correct_OrbitIndex(SPftn58sparse);
    
    save super_ftn58sparse.mat SPftn58sparse -v7.3